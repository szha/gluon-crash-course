# Manipulate data with `ndarray`

We’ll start by introducing the `NDArray`, MXNet’s primary tool for storing and transforming data. If you’ve worked with `NumPy` before, you’ll notice that a NDArray is, by design, similar to NumPy’s multi-dimensional array. 

## Get started

To get started, let's import the `ndarray` package (`nd` is shortform) from MXNet.

<!-- we can remove the --pre flag after release 1.2 -->

```{.python .input  n=1}
# Uncomment the following line to install the latest MXNet
# !pip install --pre mxnet
# Or use the following version to accelerate Intel CPU performance.
# !pip install --pre mxnet-mkl

from mxnet import nd
```

Next, let's see how to create a 2D array (also called a matrix) with values from two sets of numbers: 1, 2, 3 and 4, 5, 6. This might also be referred to as a tuple of a tuple of integers.

```{.python .input  n=8}
a = nd.array(((1,2,3),(5,6,7)))
a
```

We can also create a very simple matrix with the same shape (2 rows by 3 columns), but fill it with 1s.

```{.python .input  n=9}
ones = nd.ones((2,3))
ones
```

Often we’ll want to create arrays whose values are sampled randomly. For example, sampling values uniformly between -1 and 1. Here we create the same shape, but with random sampling.

```{.python .input  n=10}
rand_uniform = nd.random.uniform(-1,1,(2,3))
rand_uniform
```

You can also fill an array of a given shape with a given value, such as `2.0`.
<!-- added to improve multiplication example -->

```{.python .input  n=11}
twos = nd.full((2,3), 2.0)
twos
```

As with NumPy, the dimensions of each NDArray are accessible by accessing the `.shape` attribute. We can also query its `size`, which is equal to the product of the components of the shape. In addition, `.dtype` tells the data type of the stored values.

```{.python .input  n=12}
(a.shape, a.size, a.dtype)
```

## Operations

NDArray supports a large number of standard mathematical operations. Such as element-wise multiplication:

```{.python .input  n=13}
a * twos
```

Exponentiation:

```{.python .input  n=15}
twos.exp()
```

And grab a matrix’s transpose to compute a proper matrix-matrix product:

```{.python .input  n=17}
nd.dot(a, a.T)
```

## Indexing

MXNet NDArrays support slicing in all the ridiculous ways you might imagine accessing your data. Here’s an example of reading a particular element, which returns a 1D array with shape `(1,)`.

```{.python .input  n=19}
a[1,2]
```

Read the second and third columns from `y`.

```{.python .input  n=20}
a[:,1:3]
```

and writing to a specific element

```{.python .input  n=21}
a[:,1:3] = 2
a
```

Multi-dimensional slicing is also supported.

```{.python .input  n=22}
a[1:2,0:2] = 4
a
```

## Converting between MXNet NDArray and NumPy

Converting MXNet NDArrays to and from NumPy is easy. The converted arrays do not share memory.

```{.python .input  n=23}
x = a.asnumpy()
(type(x), x)
```

```{.python .input  n=24}
nd.array(x)
```
